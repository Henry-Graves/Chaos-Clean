using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class InputManager : MonoBehaviour
{
//Note: we disable this so it doesn't yell at use for using serialized fields 
 //because we can leave these blank and assign them in the editor 
#pragma warning disable 649
    [SerializeField] Movement movement;
    [SerializeField] MouseLook mouseLook;
    [SerializeField] GameObject weaponHolder;
    [SerializeField] GameObject playerCamera;
    [SerializeField] GameObject gameManager;


    //Note this is public so we can disable them when the player dies. 
    public PlayerControls controls;
    PlayerControls.PlayerGroundMovementActions groundMovement;



    Vector2 horizontalInput; 
    Vector2 mouseInput;

    private void Awake()
    {
        controls = new PlayerControls();

        WeaponController weaponController = weaponHolder.GetComponent<WeaponController>();

        GameManger gameMangerScript = gameManager.GetComponent<GameManger>();

        EquiptmentManager equiptmentManager = gameManager.GetComponent<EquiptmentManager>();

        ButtonInteractor buttonInteractor = playerCamera.GetComponent<ButtonInteractor>();


        //Set the overall input map generated by c# class
        groundMovement = controls.PlayerGroundMovement;

        //subscribe to the ground movement 
        groundMovement.HorizontalMovement.performed += ctx => horizontalInput = ctx.ReadValue<Vector2>();

        //subscribe to our jump controls 
        //Note we don't need any context to jump as we already check the is grounded and what not in the
        //Movement script, so we use underscore
        groundMovement.Jump.performed += _ => movement.OnJumpPressed();

        //Subscribe to the interaction request.
        groundMovement.Interact.started += _ => movement.RequestInteract();
        groundMovement.Interact.canceled += _ => movement.CancelInteract();

        // Interact with the button as well
        groundMovement.Interact.started += _ => buttonInteractor.SendRay();

        //Now lets update the camera rotations 
        groundMovement.MouseX.performed += ctx => mouseInput.x = ctx.ReadValue<float>();
        groundMovement.MouseY.performed += ctx => mouseInput.y = ctx.ReadValue<float>();

        //Attack stuff
        groundMovement.Attack.performed += _ => weaponController.RequestAttack();
        groundMovement.Mop.performed += _ => weaponController.RequestClean();

        //Ui Stuff
        groundMovement.Pause.performed += _ => gameMangerScript.PauseOrUnpauseGame();

        //Equipment stuff
        groundMovement.CycleEquiptment.performed += _ => equiptmentManager.CycleEquiptment();

        groundMovement.UseEquiptment.started += _ => equiptmentManager.DeployCurrentEquiptment();
        groundMovement.UseEquiptment.canceled += _ => equiptmentManager.DeployCurrentEquiptment();

        groundMovement.HotKey1.performed += _ => equiptmentManager.RequestHotKey(0); 
        groundMovement.HotKey2.performed += _ => equiptmentManager.RequestHotKey(1); 
        groundMovement.HotKey3.performed += _ => equiptmentManager.RequestHotKey(2); 
        groundMovement.HotKey4.performed += _ => equiptmentManager.RequestHotKey(3);
        groundMovement.HotKey5.performed += _ => equiptmentManager.RequestHotKey(4);


    }

    private void Update()
    {
        mouseLook.RecieveInput(mouseInput);
        movement.RecieveInput(horizontalInput);
    }

    private void OnEnable()
    {
        controls.Enable();
    }

    private void OnDestroy()
    {
        controls.Disable(); 
    }


    private void OnDisable()
    {
        controls.Disable();
    }

    //
}
